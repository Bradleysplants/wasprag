// src/utils/ragPipeline.js (ESM Version - Corrected NER Handling - COMPLETE)

// Use import syntax
import { generateChainOfThoughtResponse, generateTextEmbedding, extractEntities } from './languageModel';
import { trefleApiTools } from './trefleApi';
// Assuming vectorDatabase.js is refactored to ESM and exports named functions
import { queryVectorDatabase, storePlantInfoWithEmbedding } from './vectorDatabase'; // Adjust path if needed

// --- Helper Functions ---
/**
 * Safely parses a string into a float, returning a default value if parsing fails or input is undefined.
 * @param {string|number|undefined} value - The value to parse.
 * @param {number} defaultValue - The default value to return on failure.
 * @returns {number} The parsed float or the default value.
 */
function safeParseFloat(value, defaultValue) {
  if (value === undefined) return defaultValue;
  const parsed = parseFloat(value);
  return isNaN(parsed) ? defaultValue : parsed;
}

/**
 * Safely parses a string into an integer, returning a default value if parsing fails or input is undefined.
 * @param {string|number|undefined} value - The value to parse.
 * @param {number} defaultValue - The default value to return on failure.
 * @returns {number} The parsed integer or the default value.
 */
function safeParseInt(value, defaultValue) {
  if (value === undefined) return defaultValue;
  const parsed = parseInt(String(value), 10); // Ensure input is string for parseInt
  return isNaN(parsed) ? defaultValue : parsed;
}

// --- JSDoc Type Definitions ---
/**
 * Represents context information about a plant.
 * @typedef {Object} PlantContextItem
 * @property {string|number} [id] - Unique identifier, often from the database or API.
 * @property {string} name - Common name of the plant.
 * @property {string} [scientificName] - Scientific name.
 * @property {string} [description] - General description.
 * @property {string} [careInfo] - Information about plant care.
 * @property {string} [soilNeeds] - Information about soil requirements.
 * @property {string} [source] - Where the information came from (e.g., 'Database', 'Trefle API').
 */
/**
 * Represents the result of the RAG pipeline processing.
 * @typedef {Object} PipelineResult
 * @property {string} answer - The final answer generated by the LLM.
 * @property {string[]} sources - A list of unique sources used to generate the answer.
 */
/**
 * Represents a plant item from the Trefle API list/search results.
 * @typedef {Object} TreflePlantListItem
 * @property {number} id - Trefle's unique ID for the plant.
 * @property {string} [common_name] - Common name from Trefle.
 * @property {string} scientific_name - Scientific name from Trefle.
 * @property {string} [image_url] - URL to an image.
 * @property {string} [link] - Link to Trefle's page for the plant.
 * @property {number} [score] - Relevance score from search.
 */
/**
 * Represents a formatted context item passed to the LLM.
 * (Subset of PlantContextItem, defining expectations for LLM function)
 * @typedef {Object} ContextItem
 * @property {string} name
 * @property {string} [scientificName]
 * @property {string} [description]
 * @property {string} [careInfo]
 * @property {string} [soilNeeds]
 * @property {string} source
 */

// --- RAG Pipeline Class ---
class RagPipeline {
  constructor() {
    // Initialize configuration from environment variables or defaults
    this.topK = safeParseInt(process.env.RAG_TOP_K, 5);
    this.similarityThreshold = safeParseFloat(process.env.RAG_SIMILARITY_THRESHOLD, 0.7);
    console.log(`RAG Pipeline initialized with topK=${this.topK}, threshold=${this.similarityThreshold}`);
  }

  async processQuery(query) {
    console.log(`RAG Pipeline processing query: "${query}"`);
    try {
      // 1. Generate embedding for the input query
      const queryEmbedding = await generateTextEmbedding(query);
      console.log("Generated query embedding.");

      // 2. Retrieve initial context from the vector database
      const retrievedContext = await this.retrieveContext(queryEmbedding);

      let finalContext = retrievedContext;

      // 3. Check if retrieved context is sufficient, if not, augment with API calls
      if (this.isContextInsufficient(retrievedContext, query)) {
        console.log("Context insufficient based on rules, attempting augmentation via API...");
        const apiContext = await this.augmentWithApiCalls(query); // Uses NER internally now

        // Combine retrieved and API contexts, removing duplicates by ID
        const combined = [...retrievedContext, ...apiContext];
        const uniqueIds = new Set();
        finalContext = combined.filter(item => {
            // Use item.id if available for deduplication
            const itemId = item.id;
            if (itemId !== undefined && itemId !== null) {
                if (uniqueIds.has(itemId)) {
                    console.log(`[Deduplication] Removing duplicate ID: ${itemId} (Name: ${item.name})`);
                    return false; // Skip duplicate
                }
                uniqueIds.add(itemId);
            }
            return true; // Keep unique items or items without an ID
        });
        console.log(`Combined context size after augmentation & deduplication: ${finalContext.length}`);
      } else {
        console.log("Retrieved context deemed sufficient, skipping augmentation.");
      }

      // 4. Generate the final response using the prepared context
      return await this.generateResponse(query, finalContext);

    } catch (error) {
      // Handle errors during the pipeline execution
      console.error('Error in RAG pipeline:', error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        answer: `I encountered an internal error while processing your request: ${errorMessage}. Please check the server logs for more details.`,
        sources: ['Error State']
      };
    }
  }

  async retrieveContext(queryEmbedding) {
    try {
      console.log(`Retrieving context from vector DB with threshold ${this.similarityThreshold} and topK ${this.topK}...`);
      // Assuming queryVectorDatabase returns results with schema matching PlantContextItem fields
      const results = await queryVectorDatabase(queryEmbedding, this.topK, this.similarityThreshold);
      console.log(`Retrieved ${results.length} context items from vector database.`);
      // Map database results to the standard context item structure (may be redundant if already matching)
      return results.map(r => ({
        id: r.id, // Ensure ID is passed through
        name: r.name || 'Unknown Plant',
        scientificName: r.scientificName ?? undefined,
        description: r.description ?? null,
        careInfo: r.careInfo ?? undefined,
        soilNeeds: r.soilNeeds ?? undefined,
        source: r.source ?? 'Database', // Default source if missing
      }));
    } catch (error) {
      console.error('Error retrieving context from vector database:', error);
      return []; // Return empty array on failure to prevent crashing pipeline
    }
  }

  isContextInsufficient(context, query) {
    // Rule 1: Not enough items retrieved
    if (!context || context.length < 2) {
      console.log(`Context insufficient: Found ${context?.length ?? 0} items (less than 2). Augmenting.`);
      return true;
    }
    // Rule 2: Query asks for specific details, but context lacks them
    const specificTerms = [
      'care', 'water', 'sunlight', 'soil', 'fertilize', 'prune', 'disease', 'pest',
      'propagate', 'grow', 'plant', 'flower', 'identify', 'toxic', 'edible', 'height', 'bloom time'
    ];
    const queryLower = query.toLowerCase();
    const queryHasSpecificTerm = specificTerms.some(term => queryLower.includes(term));

    if (queryHasSpecificTerm) {
      // Check if *any* context item has substantial detail in relevant fields
      const contextHasDetails = context.some(item =>
        (item.careInfo && item.careInfo.trim().length > 10) ||
        (item.soilNeeds && item.soilNeeds.trim().length > 10) ||
        (item.description && item.description.trim().length > 50) // Check description length too
      );
      if (!contextHasDetails) {
        console.log("Context insufficient: Query contains specific terms, but retrieved context lacks detailed fields. Augmenting.");
        return true;
      }
    }
    // If rules didn't trigger, assume context is sufficient
    // console.log("Context deemed sufficient based on current rules."); // Optional: Reduce log noise
    return false;
  }

  async augmentWithApiCalls(query) {
    const apiResults = []; // Stores successfully fetched and formatted PlantContextItems
    const searchedTerms = new Set(); // Tracks terms (strings) already used for API calls
    const processedPlantIds = new Set(); // Tracks plant IDs already added to apiResults

    console.warn(`\n --- [CONTEXT AUGMENTATION START - WITH NER] Query: "${query}" ---`);

    try {
      // 1. Extract potential plant names using NER.
      //    The extractEntities function should return results already filtered
      //    for PLANT_COMMON/PLANT_SCI and score >= threshold.
      console.log('[Augment] Calling NER: extractEntities...');
      let entities = await extractEntities(query); // Expects NerEntity[]
      console.log(`[Augment] Filtered NER results received from extractEntities:`, JSON.stringify(entities, null, 2));

      if (!Array.isArray(entities)) {
        console.error('[Augment ERROR] NER (extractEntities) did not return an array! Output:', entities);
        entities = [];
      }

      // 2. Map the valid entities to cleaned names and apply application-specific filtering.
      //    NO NEED for external label/score filtering here - it's done inside extractEntities.
      const extractedNames = entities // Use the pre-filtered entities
        .map(entity => entity.word.replace(/##/g, '').trim().toLowerCase()) // Clean subword tokens and normalize case
        .filter(name => name.length > 2 && !['plant', 'flower', 'tree', 'garden', 'leaf', 'root'].includes(name)); // Optional: Filter very generic terms

      const uniqueExtractedNames = Array.from(new Set(extractedNames));
      let searchTerms = [];

      // 3. Decide which terms to use for Trefle API search
      console.warn(`[Augment Name Filter] Unique valid names after mapping & generic term filter: [${uniqueExtractedNames.join(', ')}]`); // Clarified log
      if (uniqueExtractedNames.length > 0) {
        searchTerms = uniqueExtractedNames; // Prioritize NER results
        console.warn(`>>> [AUGMENT DECISION] Using NER extracted names for API search: [${searchTerms.join(', ')}] <<<`);
      } else {
        searchTerms = [query]; // Fallback to the original query if NER is unhelpful
        console.warn(`>>> [AUGMENT DECISION] NER found no relevant names passing filters. Using RAW QUERY for API search: "${query}" <<<`);
      }

      console.log(`[Augment] Preparing to call Trefle API for terms: [${searchTerms.join(', ')}]`);

      // 4. Iterate through search terms and query Trefle API
      for (const term of searchTerms) {
        const normalizedTerm = term.toLowerCase().trim();
        // Skip empty terms or terms already processed
        if (!normalizedTerm || searchedTerms.has(normalizedTerm)) {
          continue;
        }
        searchedTerms.add(normalizedTerm); // Mark this string term as searched

        console.log(`[Augment API] Attempting Trefle lookup for term: "${term}"...`);
        // Optional delay to prevent rapid-fire API calls if needed
        await new Promise(resolve => setTimeout(resolve, 200)); // Small delay

        let plantInfo = null; // Holds FormattedPlantData | null from Trefle tool

        // Try fetching directly by name first
        try {
          console.log(`[Augment API]   Trying getPlantByName("${term}")...`);
          plantInfo = await trefleApiTools.getPlantByName(term);
        } catch (err) {
          console.error(`[Augment API]   Error during getPlantByName for "${term}":`, err instanceof Error ? err.message : String(err));
          plantInfo = null;
        }

        // If found by name, has an ID, and hasn't been added yet
        if (plantInfo && plantInfo.id && !processedPlantIds.has(plantInfo.id)) {
          console.log(`[Augment API]   SUCCESS: Found details for "${term}" (ID: ${plantInfo.id}) via getPlantByName.`);
          // Map FormattedPlantData to PlantContextItem
          const contextItem = {
              id: plantInfo.id,
              name: plantInfo.name, // Should be common name from formatter
              scientificName: plantInfo.scientificName,
              description: plantInfo.description ?? null,
              careInfo: plantInfo.careInfo,
              soilNeeds: plantInfo.soilNeeds,
              source: plantInfo.source ?? `Trefle API (ID: ${plantInfo.id})`,
          };
          apiResults.push(contextItem);
          processedPlantIds.add(plantInfo.id); // Mark ID as processed
          // Store in background - fire and forget
          this.storeFetchedPlantInfo(contextItem).catch(err => console.error(`[Augment Store Bg] Error storing ${contextItem.name} (from getPlantByName):`, err));

        } else if (plantInfo && plantInfo.id && processedPlantIds.has(plantInfo.id)) {
            console.log(`[Augment API]   Skipping duplicate plant ID ${plantInfo.id} from getPlantByName result for term "${term}".`);
        } else {
          // If getPlantByName failed or yielded no result, try a general search
          console.log(`[Augment API]   getPlantByName failed, skipped, or yielded no new plant for "${term}". Trying general search...`);
          try {
            const searchResults = await trefleApiTools.searchPlants(term); // Returns TreflePlantListItem[]

            if (searchResults?.length > 0) {
              console.log(`[Augment API]   General search found ${searchResults.length} matches for "${term}". Processing top result...`);
              const topResult = searchResults[0]; // Process only the top search result

              // Check if top result has an ID and hasn't been processed yet
              if (topResult?.id && !processedPlantIds.has(topResult.id)) {
                console.log(`[Augment API]     Getting details for search result ID ${topResult.id} (${topResult?.common_name ?? topResult?.scientific_name})...`);
                // Get the formatted details using the ID
                const plantDetails = await trefleApiTools.getPlantDetails(topResult.id); // Returns FormattedPlantData | null

                if (plantDetails && plantDetails.id) { // Check if details were successfully fetched
                  console.log(`[Augment API]     SUCCESS: Got details for search result ID ${topResult.id}.`);
                   // Map FormattedPlantData to PlantContextItem
                  const contextItem = {
                      id: plantDetails.id,
                      name: plantDetails.name,
                      scientificName: plantDetails.scientificName,
                      description: plantDetails.description ?? null,
                      careInfo: plantDetails.careInfo,
                      soilNeeds: plantDetails.soilNeeds,
                      source: plantDetails.source ?? `Trefle API (ID: ${plantDetails.id})`,
                  };
                  apiResults.push(contextItem);
                  processedPlantIds.add(plantDetails.id); // Mark ID as processed
                  // Store in background - fire and forget
                  this.storeFetchedPlantInfo(contextItem).catch(err => console.error(`[Augment Store Bg] Error storing ${contextItem.name} (from search):`, err));
                } else {
                  console.log(`[Augment API]     Failed to get details for search result ID ${topResult.id}.`);
                   processedPlantIds.add(topResult.id); // Mark ID as processed even if details failed to prevent re-tries? Maybe not. Decide policy.
                }
              } else {
                 // Log why the top result was skipped
                 if(topResult?.id && processedPlantIds.has(topResult.id)) {
                     console.log(`[Augment API]   Top search result for "${term}" (ID: ${topResult.id}) was skipped (already processed).`);
                 } else if (!topResult?.id) {
                     console.log(`[Augment API]   Top search result for "${term}" was skipped (missing ID).`);
                 } else {
                     console.log(`[Augment API]   Top search result for "${term}" was skipped (unspecified reason).`);
                 }
              }
            } else {
              console.log(`[Augment API]   General search for "${term}" yielded no results.`);
            }
          } catch (searchErr) {
            console.error(`[Augment API]   Error during general search or detail fetch for "${term}":`, searchErr instanceof Error ? searchErr.message : String(searchErr));
          }
        }
      } // end for loop for searchTerms

      console.warn(`--- [CONTEXT AUGMENTATION END] Added ${apiResults.length} items via API calls. ---`);
      return apiResults; // Return the list of successfully fetched context items

    } catch (error) {
      // Catch errors in the overall augmentation logic (e.g., NER failure if not caught internally)
      console.error('!!!!!!!!!! [AUGMENTATION FAILED] Error during context augmentation process:', error);
      return []; // Return empty array on major failure
    }
  }

  async storeFetchedPlantInfo(plantInfo) {
    // Store fetched data in the vector DB, including generating embedding
    if (!plantInfo || plantInfo.id === undefined || plantInfo.id === null) {
        console.warn("[Store Info] Skipping storage: Invalid plantInfo or missing ID.");
        return;
    }
    try {
      // Consolidate text fields for embedding generation
      const textToEmbed = [
        plantInfo.name,
        plantInfo.scientificName,
        plantInfo.description,
        plantInfo.careInfo,
        plantInfo.soilNeeds
      ].filter(val => typeof val === 'string' && val.trim().length > 0).join(' | '); // Filter out invalid/empty strings

      if (!textToEmbed) {
        console.warn(`[Store Info] Skipping storage for ${plantInfo.name || 'ID: '+plantInfo.id}: Not enough text content for embedding.`);
        return;
      }

      // Generate the embedding
      const embedding = await generateTextEmbedding(textToEmbed);
      if (!embedding || !Array.isArray(embedding) || embedding.length === 0) {
        console.error(`[Store Info] Failed to generate embedding for ${plantInfo.name || 'ID: '+plantInfo.id}. Skipping storage.`);
        return;
      }

      // Prepare the data structure expected by storePlantInfoWithEmbedding
      const dataForDb = {
          id: plantInfo.id, // Pass the ID from Trefle for potential update logic
          name: plantInfo.name, // Required
          scientificName: plantInfo.scientificName ?? null,
          description: plantInfo.description ?? null, // Use null if DB schema allows
          careInfo: plantInfo.careInfo ?? null,
          soilNeeds: plantInfo.soilNeeds ?? null,
          source: plantInfo.source ?? 'Trefle API',
      };

      // Call the database utility function to store/update
      await storePlantInfoWithEmbedding(dataForDb, embedding);
      // console.log(`[Store Info] Successfully stored/updated information about ${plantInfo.name || 'ID: '+plantInfo.id} in vector database.`); // Reduce log noise

    } catch (dbError) {
      const errorPrefix = `[Store Info] Error storing/embedding plant info for ${plantInfo.name || 'ID: '+plantInfo.id}`;
      console.error(`${errorPrefix}:`, dbError instanceof Error ? dbError.message : String(dbError));
      // Do not re-throw; allow main RAG flow to continue
    }
  }

  async generateResponse(query, context) {
    // Generate the final answer using the LLM and the prepared context
    try {
      const finalContext = Array.isArray(context) ? context : [];

      // Map and filter context items for the LLM prompt
      const contextForLLM = finalContext
        .map((item) => ({ // Map to the ContextItem structure expected by the LLM prompt function
          name: item.name ?? 'Unknown Plant',
          scientificName: item.scientificName ?? undefined,
          description: item.description ?? undefined,
          careInfo: item.careInfo ?? undefined,
          soilNeeds: item.soilNeeds ?? undefined,
          source: item.source ?? 'Unknown Source'
        }))
        .filter((item) => { // Filter out items likely unhelpful to the LLM
          const hasSpecificName = item.name && item.name !== 'Unknown Plant';
          // Check if there's *any* meaningful text content beyond just the name/source
          const hasSufficientContent = (
            (item.description && item.description.trim().length > 5) ||
            (item.careInfo && item.careInfo.trim().length > 5) ||
            (item.soilNeeds && item.soilNeeds.trim().length > 5) ||
            (item.scientificName && item.scientificName.trim().length > 0) // Consider scientific name as content
          );
          return hasSpecificName && hasSufficientContent;
        });

      // Handle case where no useful context remains after filtering
      if (contextForLLM.length === 0) {
        console.warn("No valid context items could be prepared for the language model after filtering.");
        // Try generating without context as a fallback? Or return specific message.
        // Option 1: Try without context (might hallucinate)
        // console.log("Attempting to generate response without specific context...");
        // const response = await generateChainOfThoughtResponse(query, []);
        // Option 2: Return helpful message
        return {
          answer: "I couldn't find enough relevant information in my knowledge base to answer your question accurately about that specific topic. Could you try rephrasing or asking about something else?",
          sources: ['Context Preparation Failed'] // Indicate failure reason
        };
      }

      // Generate the response using the LLM
      console.log(`Generating final response with ${contextForLLM.length} context items.`);
      const response = await generateChainOfThoughtResponse(query, contextForLLM); // Assumes this returns { answer, sources }

      // Return the structured response
      return {
        answer: response.answer,
        // Get unique sources from the context items actually used by the LLM
        sources: contextForLLM.map(item => item.source).filter((source, index, self) => source && self.indexOf(source) === index) // Ensure source exists
      };
    } catch (error) {
      // Handle errors during LLM response generation
      console.error('Error generating response:', error);
      return {
        answer: "I encountered an error while trying to generate the final response. Please check the system logs or try again later.",
        sources: ['Error in Response Generation']
      };
    }
  }
}

// --- Export Singleton Instance ---
// Ensures only one instance of the pipeline exists
export const ragPipeline = new RagPipeline();